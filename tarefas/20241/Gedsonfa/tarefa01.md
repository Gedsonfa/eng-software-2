# Tarefa 01 - Git e Github com Markdown

* [Gedson Fernandes de Araújo](https://github.com/Gedsonfa)
* [@Gedsonfa](https://github.com/Gedsonfa)
* gedsonfda@gmail.com

# ScheduleSphere

## Descrição do projeto

O ScheduleSphere é um sistema de gerenciamento de horários, facilitando a administração de tempo das suas responsabilidades.

# Equipe

[Felippe da Silva Guedes](https://github.com/uFelippeSilva)
[José Gabriel Dias de Oliveira](https://github.com/Igwbriel)
[Davi Natan Vieira de Oliveira](https://github.com/DaviNatan10)
[Gedson Fernandes de Araújo](https://github.com/Gedsonfa)

# Repositório
[ScheduleSphere](https://github.com/Gedsonfa/ScheduleSphere)
 
# Tecnologias utilizadas
<p>
    <img src="https://cdn.icon-icons.com/icons2/3207/PNG/512/js_node_icon_196124.png" width="32"/>
    <img src="https://cdn.icon-icons.com/icons2/2107/PNG/512/file_type_light_prisma_icon_130444.png" width="32"/>
    <img src="https://cdn.icon-icons.com/icons2/2389/PNG/512/next_js_logo_icon_145038.png" width="32"/>
    <img src="https://cdn.icon-icons.com/icons2/2107/PNG/512/file_type_vscode_icon_130084.png" width="32"/>
     <img src="https://cdn.icon-icons.com/icons2/2107/PNG/512/file_type_docker_icon_130643.png" width="32"/>
    <img src="https://cdn.icon-icons.com/icons2/729/PNG/512/google_icon-icons.com_62736.png" width="32"/>
</p>


# Matriz de Competências

| Membro | Competências |
| ------ | ------------ |
| Felippe | Software Tester, JavaScript, Dart, C, Python |
| José Gabriel | Developer JavaScript, React, Next.JS, MySql |
| Davi | Software Analyst, JavaScript, Dart, C, Python |
| Gedson | Software Tester, Gerente, Python, Django, JavaScript |


# Tutoriais

|Nome|Descrição|Link|
|-|-|-|
|JS|Curso em Vídeo - JavaScript |[Clique aqui](https://www.youtube.com/watch?v=BXqUH86F-kA&list=PLntvgXM11X6pi7mW0O4ZmfUI1xDSIbmTm)|
|Prisma|Learn Prisma In 60 Minutes|[Clique aqui](https://www.youtube.com/watch?v=RebA5J-rlwg&pp=ugMICgJwdBABGAHKBQ90dXRvcmlhbCBwcmlzbWE%3D)|
|Next.js|Curso de Next.js |[Clique aqui](https://www.youtube.com/watch?v=XHrbg2iYNCg&list=PLnDvRpP8BnezfJcfiClWskFOLODeqI_Ft)|
|Docker|Introdução ao Docker para iniciantes |[Clique aqui](https://www.youtube.com/watch?v=01MR38eDXz8&pp=ygUPdHV0b3JpYWwgZG9ja2Vy)|


# Sobre Git

| Termo       | Resumo                                                                                                      |
| ------------ | ----------------------------------------------------------------------------------------------------------------- |
| Branches      | Um branch no Git é simplesmente um ponteiro móvel para um commits. O nome do branch padrão no Git é master. Conforme você começa a fazer commits, você recebe um branch master que aponta para o último commit que você fez. Cada vez que você faz um novo commit, ele avança automaticamente.           |
| Pull requests|           você pode usar um pull request para informar a outras pessoas sobre as alterações que deseja fazer e solicitar feedback. Depois que uma solicitação pull for aberta, você poderá discutir e revisar as possíveis alterações com os colaboradores e adicionar mais alterações, se necessário. Você pode adicionar pessoas específicas como revisores de seu pull request, o que mostra que você deseja o feedback delas sobre suas alterações! Quando um pull request estiver pronto, ele poderá ser mesclado em sua ramificação principal.                                                                        |
|  Versionamento Semântico      |                Versionamento Semântico, em inglês “Semantic Versioning”, é um padrão de regras para manter um acompanhamento de versões no desenvolvimento de códigos. Um modelo geral que todas as pessoas usuárias podem entender e utilizar.                                                         |
|    Conventional Commits    |            A especificação do Conventional Commits é uma convenção simples para utilizar nas mensagens de commit. Ela define um conjunto de regras para criar um histórico de commit explícito, o que facilita a criação de ferramentas automatizadas baseadas na especificação. Esta convenção se encaixa com o SemVer, descrevendo os recursos, correções e modificações que quebram a compatibilidade nas mensagens de commit.

# Testes de Software

Os testes de software são uma parte fundamental do ciclo de desenvolvimento de software, garantindo que o software funcione conforme o esperado e que os erros sejam identificados e corrigidos antes do lançamento. Dentro do universo de testes de software, os testes de unidade ocupam um lugar de destaque.
Testes de Unidade

Os testes de unidade são um tipo de teste de software que foca na menor parte testável de uma aplicação, geralmente uma função, método ou classe. O objetivo é verificar se cada unidade de código funciona corretamente isoladamente. Aqui estão alguns pontos-chave sobre testes de unidade:

Objetivos

* Verificação de Funcionamento: Assegurar que cada unidade individual de código funcione conforme o esperado.
* Detecção Precoce de Erros: Identificar e corrigir erros no início do ciclo de desenvolvimento, o que reduz o custo de correção.
* Documentação: Servir como documentação viva do comportamento esperado do código.
* Facilitar Mudanças: Ajudar a garantir que novas mudanças ou adições ao código não quebrem funcionalidades existentes (refatoração segura).

Características

* Isolamento: Cada unidade é testada isoladamente, sem dependências externas como banco de dados, serviços externos ou outras unidades de código.
* Automatização: Os testes de unidade são geralmente automatizados e integrados ao pipeline de desenvolvimento contínuo (CI/CD).
* Repetibilidade: Devem ser repetíveis e proporcionar resultados consistentes sempre que executados.
* Rapidez: Devido ao seu escopo reduzido, os testes de unidade são rápidos de executar.

Ferramentas Comuns

* JUnit: Usado para testar unidades de código Java.
* NUnit: Ferramenta para testes de unidade em C#.
* pytest: Popular no ecossistema Python.
* Mocha: Utilizado para testes de unidade em JavaScript (Node.js).
* xUnit: Família de ferramentas de teste de unidade para várias linguagens de programação.

Estrutura de um Teste de Unidade

Um teste de unidade típico segue a estrutura Arrange, Act, Assert (AAA):

* Arrange: Configurar o cenário de teste e inicializar os objetos necessários.
* Act: Executar a unidade de código que está sendo testada.
* Assert: Verificar se o resultado obtido corresponde ao esperado.